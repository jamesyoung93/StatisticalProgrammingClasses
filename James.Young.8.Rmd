---
title: "8 Processing Text Homework"
author: "James Young"
date: "7/17/2019"
output:
  word_document: default
  pdf_document: default
  html_document: default
---

There are six exercises below. You are required to provide solutions for at least four of the six. You are required to solve at least one exercise in R, and at least one in SAS. You are required to provide five solutions, each solution will be worth 10 points. Thus, you may choose to provide both R and SAS solutions for a single exercise, or you may solve five of the sixth problems, mixing the languages as you wish.

If you choose SAS for an exercise, you may use `IML`, `DATA` operations or `PROC SQL` at your discretion.

*Warning* I will continue restricting the use of external libraries in R, particularly `tidyverse` libraries. You may choose to use `ggplot2`, but take care that the plots you produce are at least as readable as the equivalent plots in base R. You will be allowed to use whatever libraries tickle your fancy in the midterm and final projects.

## Reuse

For many of these exercises, you may be able to reuse functions written in prior homework. Define those functions here.

```{r}
#To turn matrix into csv compatible string for question 1
stringmaker <- function(x){
  csvnat <- do.call(paste, c(as.list(colnames(x)), sep=",", do.call(paste,c(x, sep=",")) ))
  n <- dim(x)[2]
  rep1 <- strrep("[^,]+,", n)
 
  rep1 <- gsub(",$","",rep1)

  rep1 <- paste0("(",rep1,"),")
  
  o = gsub(rep1, "\\1\n", paste(csvnat, collapse = ","))
  
  
  return(o)
}

```


# Exercise 1 Please Grade.

Write a loop or a function to convert a matrix to a `CSV` compatible string. Given a matrix of the form

C1   | C2   | C3
-----|------|----
a    | b    | c 
d    | e    | f
g    | h    | i

produce a string of the form

```a,b,c\nd,e,f\ng,h,i``` 

where `\n` is the newline character.

You are only required to convert a matrix to CSV format, but you may choose to write code to convert data tables to CSV; in this case, include column names in the output string. Use `NATR332.DAT` as a test case.

```{r}
NATR332.DAT <- data.frame(
  Y1 = c(146,141,135,142,140,143,138,137,142,136),
  Y2 = c(141,143,139,139,140,141,138,140,142,138)
)


stringmaker(NATR332.DAT)
```


If you choose SAS, I've include the NATR332 data table and framework code for IML in the template. I used the `CATX` function in IML. I found I could do this in one line in R, with judicious use of `apply`, but I haven't found the equivalent in IML. Instead, I used a pair of nested loops to "accumulate" an increasingly longer string.




# Exercise 3 Please Grade.

Calculate MSW, MSB, $F$ and $p$ for the data from Wansink Table 1 (Homework 4, Exercise 6) where

$$
MSB = \frac{\sum_i n_i(x_i-\bar{x})^2}{k-1}
$$

$$
MSW =  \frac{\sum_i (n_i-1)s_i^2}{N-k}
$$

Start with the strings:

```{r}
Means <- "268.1 271.1 280.9 294.7 285.6 288.6 384.4"
StandardDeviations <- "124.8 124.2 116.2 117.7 118.3 122.0 168.3"
SampleSizes <- "18 18 18 18 18 18 18"
```

Tokenize the strings, then convert the tokens to a create vectors of numeric values. Use these vectors to compute and print $MSW$, $MSB$, $F$ and $p$.

```{r}
Mean1 = as.numeric(strsplit(Means,split=" ")[[1]])
StandardDeviations1 = as.numeric(strsplit(StandardDeviations, split=" ")[[1]])
SampleSizes1 = as.numeric(strsplit(SampleSizes, split=" ")[[1]][1])


ms.len  = length(Mean1)
msb.nu = 0
msw.nu = 0
for(i in 1:length(Mean1)){
  msb.nu = (SampleSizes1 * ((Mean1[[i]]-mean(Mean1))^2)) + msb.nu
  msw.nu = ((SampleSizes1 - 1) * StandardDeviations1[[i]]^2)+msw.nu
  
}
msb = msb.nu/(ms.len-1)
msw = msw.nu/(length(StandardDeviations1)*SampleSizes1 - length(StandardDeviations1))

F_ratio = msb/msw


p_value = pf(F_ratio, (length(Mean1)-1), (length(StandardDeviations1) * SampleSizes1 - length(StandardDeviations1)), lower.tail=FALSE)


msb
msw
F_ratio
p_value


```




# Exercise 5 Please Grade.

Use the file `openmat2015.csv` from D2L. These data are from https://news.theopenmat.com/high-school-wrestling/high-school-wrestling-rankings/final-2015-clinch-gear-national-high-school-wrestling-individual-rankings/57136. This is a list of top-ranked high school wrestlers in 2015, their high `School`, `Weight` class and in some cases the `College` where they expected to enroll and compete after high school. 

We wish to know how many went on to compete in the national championship in 2019, so we will merge this table with the data from Homework 7, `ncaa2019.csv`.  The `openmat2015.csv` data contains only a single column, `Name`. You will need to split the text in this column to create the columns `First` and `Last` required to merge with `ncaa2019.csv`. 

**Do not print these tables in the submitted work** Instead, print a contingency table comparing `Weight` for 2015 and `Weight` for 2019. What is the relationship between high school and college weight classes? You may instead produce a scatter plot or box-whisker plot, using high school weight class as the independent variable.

If you do this in SAS, use the `openmat2015SAS.csv` file, it will import `College` correctly.

```{r}
r <- read.csv("C://data/ncaa2019.csv")
d <- read.csv("C://data/openmat2015.csv")

d$Name <- as.character(d$Name)

First = sapply(strsplit(d$Name, ' '), function(x) x[1])
Last = sapply(strsplit(d$Name, ' '), function(x) x[length(x)])
r$Last <- as.character(r$Last)
r$First <- as.character(r$First)
d$Weight2015 <- as.numeric(d$Weight)
r$Weight2019 <- as.numeric(r$Weight)
open2015 <- cbind(First, Last, d$Weight2015)
ncaa2019 <- cbind(r$First, r$Last, r$Weight2019)
open2015 <-as.data.frame(open2015)
ncaa2019 <-as.data.frame(ncaa2019)
open2015$Weight2015 <-open2015$V3
ncaa2019$Weight2019 <-ncaa2019$V3
ncaa2019$First <- ncaa2019$V1
ncaa2019$Last <- ncaa2019$V2
ncaa2019$V1 <- NULL
ncaa2019$V2 <- NULL
open2015$V3 <- NULL
ncaa2019$V3 <- NULL
#makes merged table with first name, last name, and weights from 2015 and 2019
merged = merge(open2015, ncaa2019, all =T)
merged = na.omit(merged)
#contingency table for condensed information
contingency <- ftable(merged$Weight2015 ~ merged$Weight2019)
contingency

plot(merged$Weight2015 ~ merged$Weight2019)



```



# Exercise 6 Please Grade.

Use file `openmat2015.csv` from Exercise 6, and use partial text matching to answer these questions. To show your results, print only the rows from the table that match the described text patterns, but to save space, print only `Name`, `School` and `College`. Each of these can be answered in a single step.

```{r}
d <- read.csv("C://data/openmat2015.csv")
```

- Which wrestlers come from a `School` with a name starting with `St.`?

```{r}
d.schoolST = d[grepl("St.", d$School),]
d.schoolST


```

- Which wrestlers were intending to attend an Iowa `College`?

```{r}
d.CollegeIowa = d[grepl("Iowa", d$College),]
d.CollegeIowa


```

- Which wrestlers were intending to start `College` in 2016 or 2017 (`College` will end with 16 or 17)?

```{r}
d.p = d[grepl(" '16", d$College),]
d.p2 = d[grepl(" '17", d$College),]
d.p3 = rbind(d.p2, d.p)
d.p3
```

- Which wrestlers are intending compete in a sport other than wrestling? (look for a sport in parenthesis in the `College` column. Note - `(` is a special character in regular expressions, so to match the exact character, it needs to be preceded by the escape character `\`. However, `\` in strings is a special character, so itself must be preceded by the escape character. 

```{r}
dt = d[grepl("\\(", d$College),]
dt

```


Done